# 变量赋值

# 重新声明与再次赋值

调用了 os.Open 的声明为

```go
f, err := os.Open(name)
```

该语句声明了两个变量 f 和 err。在几行之后，又通过

```go
d, err := f.Stat()
```

调用了 f.Stat。它看起来似乎是声明了 d 和 err。注意，尽管两个语句中都出现了 err，但这种重复仍然是合法的：err 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 f.Stat 使用的是前面已经声明的 err，它只是被重新赋值了而已。

在满足下列条件时，已被声明的变量 v 可出现在 := 声明中：

- 本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量§），
- 在初始化中与其类型相应的值才能赋予 v
- 此次声明中至少另有一个变量是新声明的

当在有嵌套关系的作用域内声明了相同名的值时，就产生了所谓的 Variable Shadow:

```go
i := 1
{
	i := i
	i = i * 2
	fmt.Println(i) // 2
}
fmt.Println(i) // 1
```

花括号内为新的作用于，在其中重新声明了变量 i。此时花括号内的新变量 i，shadow 了外面作用域的 i。
