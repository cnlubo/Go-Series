# 变量与常量

# 变量声明

Go 语言里面定义变量有多种方式。使用 `var` 关键字是 Go 最基本的定义变量方式，与 C 语言不同的是 Go 把变量类型放在变量名后面：

```go
// 定义一个名称为 variableName，类型为"type"的变量
var variableName type

// 定义三个类型都是 type 的变量
var vname1, vname2, vname3 type

// 初始化“variableName”的变量为“value”值，类型是“type”
var variableName type = value

/*
定义三个类型都是"type"的变量,并且分别初始化为相应的值 vname1 为 v1，vname2 为 v2，vname3 为 v3
*/
var vname1, vname2, vname3 type= v1, v2, v3

// 定义多个变量
var (
	home   = os.Getenv("HOME")
	user   = os.Getenv("USER")
	gopath = os.Getenv("GOPATH")
)

/*
 定义三个变量，它们分别初始化为相应的值 vname1 为 v1，vname2 为 v2，vname3 为 v3 编译器会根据初始化的值自动推导出相应的类型
*/
vname1, vname2, vname3 := v1, v2, v3
```

`:=` 这个符号直接取代了 `var` 和 `type`，这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用 `var` 方式来定义全局变量。`_`(下划线)是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值 `35` 赋予 `b`，并同时丢弃 `34`：

```go
_, b := 34, 35
```

Go 对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了`i`但未使用。

```go
package main

func main() {
  var i int
}
```

# 重新声明与再次赋值

调用了 os.Open 的声明为

```go
f, err := os.Open(name)
```

该语句声明了两个变量 f 和 err。在几行之后，又通过

```go
d, err := f.Stat()
```

调用了 f.Stat。它看起来似乎是声明了 d 和 err。注意，尽管两个语句中都出现了 err，但这种重复仍然是合法的：err 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 f.Stat 使用的是前面已经声明的 err，它只是被重新赋值了而已。

在满足下列条件时，已被声明的变量 v 可出现在 := 声明中：

- 本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量§），
- 在初始化中与其类型相应的值才能赋予 v
- 此次声明中至少另有一个变量是新声明的

当在有嵌套关系的作用域内声明了相同名的值时，就产生了所谓的 Variable Shadow:

```go
i := 1
{
	i := i
	i = i * 2
	fmt.Println(i) // 2
}
fmt.Println(i) // 1
```

花括号内为新的作用于，在其中重新声明了变量 i。此时花括号内的新变量 i，shadow 了外面作用域的 i。

# 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。变量的生命周期与变量的作用域有着不可分割的联系：

- 全局变量：它的生命周期和整个程序的运行周期是一致的；
- 局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；
- 形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。

```go
for t := 0.0; t < cycles*2*math.Pi; t += res {
    x := math.Sin(t)
    y := math.Sin(t*freq + phase)
    img.SetColorIndex(
        size+int(x*size+0.5), size+int(y*size+0.5),
        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
    )               // 小括号另起一行缩进，和大括号的风格保存一致
}
```

上面代码中，在每次循环的开始会创建临时变量 t，然后在每次循环迭代中创建临时变量 x 和 y。临时变量 x、y 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。

- 堆（heap）：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；
- 栈(stack)：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号`{ }`中定义的局部变量。

在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

上述代码中，函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用 Go 语言的术语说，这个局部变量 x 从函数 f 中逃逸了。相反，当函数 g 返回时，变量 `*y` 不再被使用，也就是说可以马上被回收的。因此，`*y` 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 `*y` 的存储空间，也可以选择在堆上分配，然后由 Go 语言的 GC（垃圾回收机制）回收这个变量的内存空间。

在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。虽然 Go 语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。

# 内存分配逃逸

如前文介绍，栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。

```go
func F() {
	temp := make([]int, 0, 20)
	...
}
```

类似于上面代码里面的 temp 变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。申请到栈内存好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。再来看看堆得情况之一如下代码：

```go
func F() []int{
	a := make([]int, 0, 20)
	return a
}
```

而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到堆上面了。申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。

```go
func F() {
	a := make([]int, 0, 20)     // 栈 空间小
	b := make([]int, 0, 20000) // 堆 空间过大

	l := 20
	c := make([]int, 0, l) // 堆 动态分配不定空间
}
```

像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。

## 逃逸分析（Escape analysis）

所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。在函数中申请一个新的对象：

- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给 GC（垃圾回收）处理;

注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。

逃逸分析的作用是什么呢？

- 逃逸分析的好处是为了减少 gc 的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要 gc 标记清除。
- 逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。
- 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。

## 指针逃逸

Go 可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：

```go
package main

type Student struct {
    Name string
    Age  int
}

func StudentRegister(name string, age int) *Student {
    s := new(Student) //局部变量s逃逸到堆

    s.Name = name
    s.Age = age

    return s
}

func main() {
    StudentRegister("Jim", 18)
}

```

虽然在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。终端运行命令查看逃逸分析日志：

```sh
go build -gcflags=-m
```

可见在 StudentRegister()函数中，也即代码第 9 行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。

## 栈空间不足逃逸（空间开辟过大）

```go
package main

func Slice() {
    s := make([]int, 1000, 1000)

    for index, _ := range s {
        s[index] = index
    }
}

func main() {
    Slice()
}

```

上面代码 Slice()函数中分配了一个 1000 个长度的切片，是否逃逸取决于栈空间是否足够大。

## 动态类型逃逸（不确定长度大小）

很多函数参数为 interface 类型，比如 fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。如下代码所示：

```go
package main

import "fmt"

func main() {
    s := "Escape"
    fmt.Println(s)
}
```

## 闭包引用对象逃逸

Fibonacci 数列的函数：

```go
package main

import "fmt"

func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}

func main() {
    f := Fibonacci()

    for i := 0; i < 10; i++ {
        fmt.Printf("Fibonacci: %d\n", f())
    }
}
```

输出如下：

```
 ~/go/src/gitHub/test/pool  go run main.go
Fibonacci: 1
Fibonacci: 1
Fibonacci: 2
Fibonacci: 3
Fibonacci: 5
Fibonacci: 8
Fibonacci: 13
Fibonacci: 21
Fibonacci: 34
Fibonacci: 55
```

逃逸如下：

```
 ~/go/src/gitHub/test/pool  go build -gcflags=-m
# gitHub/test/pool
./main.go:7:9: can inline Fibonacci.func1
./main.go:7:9: func literal escapes to heap
./main.go:7:9: func literal escapes to heap
./main.go:8:10: &b escapes to heap
./main.go:6:5: moved to heap: b
./main.go:8:13: &a escapes to heap
./main.go:6:2: moved to heap: a
./main.go:17:34: f() escapes to heap
./main.go:17:13: main ... argument does not escape
```

Fibonacci()函数中原本属于局部变量的 a 和 b 由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。
